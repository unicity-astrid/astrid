//! JS shim template generation.
//!
//! Produces a self-contained `JavaScript` file that:
//! 1. Defines host function wrappers (lazy-resolved, not called during Wizer init)
//! 2. Wraps the original plugin code in an IIFE with CJS module simulation
//! 3. Provides an `OpenClaw` context mock that maps to Astrid host functions
//! 4. Exports `describe-tools`, `execute-tool`, and `run-hook` for the Extism runtime
//!
//! Host functions are NOT available during Wizer pre-initialization. All host
//! function calls (config loading, plugin activation, logging) are deferred to
//! the first runtime export invocation via `_ensureActivated()`.

use std::collections::HashMap;

/// Generate the complete JS shim wrapping the given plugin code.
///
/// `plugin_code` should be the bundled CJS output from esbuild (or raw JS if `--skip-bundle`).
/// `config` is the set of config key-value pairs to bake into the shim.
#[must_use]
#[allow(clippy::implicit_hasher)]
pub fn generate(plugin_code: &str, config: &HashMap<String, serde_json::Value>) -> String {
    let config_keys = generate_config_keys(config);
    let header = generate_header(&config_keys);
    let exports = generate_exports();
    format!(
        "{header}\n// --- BEGIN PLUGIN CODE ---\n{plugin_code}\n  // --- END PLUGIN CODE ---\n  return module.exports.default || module.exports;\n}})();\n\n{exports}"
    )
}

/// Generate the shim header: host function wrappers, context mock, and IIFE open.
///
/// No host functions are called at the top level — everything is deferred.
#[allow(clippy::too_many_lines)]
fn generate_header(config_keys: &str) -> String {
    let node_polyfills = generate_node_polyfills();
    format!(
        r#"// Generated by openclaw-bridge — do not edit.
// OpenClaw → Astrid WASM shim.
//
// IMPORTANT: No host function calls during init (Wizer snapshot phase).
// All host calls are deferred to _ensureActivated(), called on first export.

// ── Host function imports (lazy — resolved on first call, not during Wizer init) ──
var _Host = Host;
var _hostFns = null;

function _getHostFn(name) {{
  if (!_hostFns) {{
    _hostFns = _Host.getFunctions();
  }}
  return _hostFns[name];
}}

// ── Memory helpers ─────────────────────────────────────────────────
function _toMem(s) {{
  return Memory.fromString(String(s));
}}

function _fromMem(offset) {{
  var m = Memory.find(offset);
  if (!m) return "";
  return m.readString();
}}

// ── Host function wrappers ─────────────────────────────────────────
function hostLog(level, msg) {{
  var lm = _toMem(level);
  var mm = _toMem(msg);
  _getHostFn("astrid_log")(lm.offset, mm.offset);
}}

function hostGetConfig(key) {{
  var km = _toMem(key);
  var result = _getHostFn("astrid_get_config")(km.offset);
  return _fromMem(result);
}}

function hostReadFile(path) {{
  var pm = _toMem(path);
  var result = _getHostFn("astrid_read_file")(pm.offset);
  return _fromMem(result);
}}

function hostWriteFile(path, content) {{
  var pm = _toMem(path);
  var cm = _toMem(content);
  _getHostFn("astrid_write_file")(pm.offset, cm.offset);
}}

function hostKvGet(key) {{
  var km = _toMem(key);
  var result = _getHostFn("astrid_kv_get")(km.offset);
  return _fromMem(result);
}}

function hostKvSet(key, value) {{
  var km = _toMem(key);
  var vm = _toMem(value);
  _getHostFn("astrid_kv_set")(km.offset, vm.offset);
}}

function hostHttpRequest(requestJson) {{
  var rm = _toMem(requestJson);
  var result = _getHostFn("astrid_http_request")(rm.offset);
  return _fromMem(result);
}}

function hostFsExists(path) {{
  var pm = _toMem(path);
  var result = _getHostFn("astrid_fs_exists")(pm.offset);
  return _fromMem(result) === "true";
}}

function hostFsMkdir(path) {{
  var pm = _toMem(path);
  _getHostFn("astrid_fs_mkdir")(pm.offset);
}}

function hostFsReaddir(path) {{
  var pm = _toMem(path);
  var result = _getHostFn("astrid_fs_readdir")(pm.offset);
  return JSON.parse(_fromMem(result));
}}

function hostFsStat(path) {{
  var pm = _toMem(path);
  var result = _getHostFn("astrid_fs_stat")(pm.offset);
  return JSON.parse(_fromMem(result));
}}

function hostFsUnlink(path) {{
  var pm = _toMem(path);
  _getHostFn("astrid_fs_unlink")(pm.offset);
}}

{node_polyfills}

// ── Host function metadata (needed by Host.getFunctions()) ──────────
// Sorted alphabetically by name — indices must match shim dispatch order.
// `results`: 1 = returns a value, 0 = void.
Host.__hostFunctions = [
  {{ name: "astrid_fs_exists", results: 1 }},
  {{ name: "astrid_fs_mkdir", results: 0 }},
  {{ name: "astrid_fs_readdir", results: 1 }},
  {{ name: "astrid_fs_stat", results: 1 }},
  {{ name: "astrid_fs_unlink", results: 0 }},
  {{ name: "astrid_get_config", results: 1 }},
  {{ name: "astrid_http_request", results: 1 }},
  {{ name: "astrid_kv_get", results: 1 }},
  {{ name: "astrid_kv_set", results: 0 }},
  {{ name: "astrid_log", results: 0 }},
  {{ name: "astrid_read_file", results: 1 }},
  {{ name: "astrid_write_file", results: 0 }}
];

// ── Config keys (baked at generation time, loaded lazily at runtime) ──
var _CONFIG_KEYS = [{config_keys}];

// ── Tool registry ──────────────────────────────────────────────────
var _registeredTools = {{}};

// ── Plugin config (populated lazily by _ensureActivated) ───────────
var _pluginConfig = {{}};

// ── OpenClaw context mock ──────────────────────────────────────────
var _openclawContext = {{
  config: _pluginConfig,
  logger: {{
    info: function(msg) {{ hostLog("info", msg); }},
    warn: function(msg) {{ hostLog("warn", msg); }},
    error: function(msg) {{ hostLog("error", msg); }},
    debug: function(msg) {{ hostLog("debug", msg); }}
  }},
  workspace: ".",
  registerTool: function(name, definition, handler) {{
    _registeredTools[name] = {{
      name: name,
      definition: definition,
      handler: handler
    }};
  }}
}};

// ── Inlined plugin code (IIFE-wrapped CJS) ─────────────────────────
var _pluginModule = (function() {{
  var module = {{ exports: {{}} }};
  var exports = module.exports;"#
    )
}

/// Generate Node.js module polyfills (`node:fs`, `node:path`, `node:os`).
///
/// These are virtual implementations backed by host functions. The shim
/// includes a `require()` polyfill that dispatches to these objects.
fn generate_node_polyfills() -> &'static str {
    r#"// ── Node.js module polyfills (node:fs, node:path, node:os) ──────────
var _virtualFs = {
  readFileSync: function(p, opts) {
    var content = hostReadFile(String(p));
    if (opts === "utf8" || (opts && opts.encoding === "utf8")) return content;
    return content;
  },
  writeFileSync: function(p, data) {
    hostWriteFile(String(p), String(data));
  },
  existsSync: function(p) {
    return hostFsExists(String(p));
  },
  mkdirSync: function(p, opts) {
    hostFsMkdir(String(p));
  },
  readdirSync: function(p) {
    return hostFsReaddir(String(p));
  },
  statSync: function(p) {
    var s = hostFsStat(String(p));
    return {
      size: s.size,
      isDirectory: function() { return s.isDir; },
      isFile: function() { return !s.isDir; },
      mtimeMs: s.mtime * 1000
    };
  },
  unlinkSync: function(p) {
    hostFsUnlink(String(p));
  }
};

var _virtualPath = {
  sep: "/",
  join: function() {
    var parts = [];
    for (var i = 0; i < arguments.length; i++) parts.push(arguments[i]);
    return parts.join("/").replace(/\/+/g, "/");
  },
  resolve: function() {
    var parts = [];
    for (var i = arguments.length - 1; i >= 0; i--) {
      parts.unshift(arguments[i]);
      if (arguments[i][0] === "/") break;
    }
    var joined = parts.join("/").replace(/\/+/g, "/");
    var segs = joined.split("/");
    var out = [];
    for (var j = 0; j < segs.length; j++) {
      if (segs[j] === "..") { if (out.length > 1) out.pop(); }
      else if (segs[j] !== "." && segs[j] !== "") out.push(segs[j]);
    }
    return "/" + out.join("/");
  },
  dirname: function(p) {
    var idx = p.lastIndexOf("/");
    return idx <= 0 ? "/" : p.substring(0, idx);
  },
  basename: function(p, ext) {
    var base = p.substring(p.lastIndexOf("/") + 1);
    if (ext && base.endsWith(ext)) base = base.substring(0, base.length - ext.length);
    return base;
  },
  extname: function(p) {
    var base = p.substring(p.lastIndexOf("/") + 1);
    var dot = base.lastIndexOf(".");
    return dot <= 0 ? "" : base.substring(dot);
  },
  normalize: function(p) {
    return p.replace(/\/+/g, "/").replace(/\/\.\//g, "/");
  },
  isAbsolute: function(p) {
    return p.length > 0 && p[0] === "/";
  }
};

var _virtualOs = {
  homedir: function() { return "/data"; },
  platform: function() { return "wasm"; },
  tmpdir: function() { return "/tmp"; },
  EOL: "\n"
};

// ── require() polyfill for Node.js modules ──────────────────────────
function require(moduleName) {
  if (moduleName === "node:fs" || moduleName === "fs") return _virtualFs;
  if (moduleName === "node:path" || moduleName === "path") return _virtualPath;
  if (moduleName === "node:os" || moduleName === "os") return _virtualOs;
  throw new Error("Cannot require module: " + moduleName + " (not polyfilled in WASM sandbox)");
}"#
}

/// Generate the Extism export functions with deferred activation.
///
/// `_ensureActivated()` is called at the top of each export function. It:
/// 1. Loads config from host (first time only)
/// 2. Calls plugin `activate()` (first time only)
#[allow(clippy::too_many_lines)]
fn generate_exports() -> String {
    r#"// ── Deferred activation (runs on first export call, NOT during Wizer init) ──
var _activated = false;

function _ensureActivated() {
  if (_activated) return;
  _activated = true;

  // Load config from host
  for (var _ci = 0; _ci < _CONFIG_KEYS.length; _ci++) {
    var _ck = _CONFIG_KEYS[_ci];
    var _cv = hostGetConfig(_ck);
    if (_cv !== undefined && _cv !== "") {
      try { _pluginConfig[_ck] = JSON.parse(_cv); }
      catch(_ce) { _pluginConfig[_ck] = _cv; }
    }
  }

  // Activate plugin
  if (typeof _pluginModule.activate === "function") {
    try {
      _pluginModule.activate(_openclawContext);
    } catch(_ae) {
      hostLog("error", "plugin activation failed: " + String(_ae));
    }
  }
}

// ── Extism exports ─────────────────────────────────────────────────
// Note: describe-tools is kept for backwards compatibility with dynamic discovery,
// but astrid_tool_call and astrid_hook_trigger are the new Phase 4 Inbound ABI.
module.exports["describe-tools"] = function() {
  _ensureActivated();
  var tools = [];
  var names = Object.keys(_registeredTools);
  for (var _ti = 0; _ti < names.length; _ti++) {
    var t = _registeredTools[names[_ti]];
    tools.push({
      name: t.name,
      description: t.definition.description || "",
      input_schema: JSON.stringify(t.definition.inputSchema || {})
    });
  }
  _Host.outputString(JSON.stringify(tools));
};

module.exports.astrid_tool_call = function() {
  _ensureActivated();
  var inputStr = _Host.inputString();
  var input;
  try {
    input = JSON.parse(inputStr);
  } catch(_pe) {
    _Host.outputString(JSON.stringify({
      content: "failed to parse tool input: " + String(_pe),
      is_error: true
    }));
    return;
  }

  var toolName = input.name;
  var tool = _registeredTools[toolName];
  if (!tool) {
    _Host.outputString(JSON.stringify({
      content: "unknown tool: " + toolName,
      is_error: true
    }));
    return;
  }

  var args;
  try {
    args = typeof input.arguments === "string" ? JSON.parse(input.arguments) : (input.arguments || {});
  } catch(_ae2) {
    args = {};
  }

  try {
    var result = tool.handler(toolName, args);
    // Detect unresolved Promise (QuickJS async without event loop)
    if (result && typeof result === "object" && typeof result.then === "function" && typeof result.__value === "undefined") {
      _Host.outputString(JSON.stringify({
        content: "Tool '" + toolName + "' requires async I/O which is not supported in the WASM sandbox. Use the Tier 2 MCP bridge (packages/openclaw-mcp-bridge/) instead.",
        is_error: true
      }));
      return;
    }
    var content = (typeof result === "string") ? result : JSON.stringify(result);
    _Host.outputString(JSON.stringify({
      content: content,
      is_error: false
    }));
  } catch(_ee) {
    _Host.outputString(JSON.stringify({
      content: "tool execution failed: " + String(_ee),
      is_error: true
    }));
  }
};

module.exports.astrid_hook_trigger = function() {
  _ensureActivated();
  var inputStr = _Host.inputString();
  var ctx;
  try {
    ctx = JSON.parse(inputStr);
  } catch(_pe2) {
    _Host.outputString(JSON.stringify({ action: "continue", data: null }));
    return;
  }

  if (typeof _pluginModule.onEvent === "function") {
    try {
      var eventData = ctx.data ? JSON.parse(ctx.data) : null;
      _pluginModule.onEvent(ctx.event, eventData);
    } catch(_he) {
      hostLog("error", "hook handler failed: " + String(_he));
    }
  }

  _Host.outputString(JSON.stringify({ action: "continue", data: null }));
};

module.exports.astrid_command_run = function() {
    _ensureActivated();
    _Host.outputString(JSON.stringify({ content: "Commands not natively supported by OpenClaw", is_error: true }));
};

module.exports.astrid_cron_trigger = function() {
    _ensureActivated();
    _Host.outputString(JSON.stringify({ content: "Cron not natively supported by OpenClaw", is_error: true }));
};
"#
    .to_string()
}

/// Generate the JS array literal for config keys.
fn generate_config_keys(config: &HashMap<String, serde_json::Value>) -> String {
    if config.is_empty() {
        return String::new();
    }
    config
        .keys()
        .map(|k| format!("\"{}\"", escape_js_string(k)))
        .collect::<Vec<_>>()
        .join(", ")
}

/// Escape a string for use in a JS string literal.
fn escape_js_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn shim_contains_exports() {
        let config = HashMap::new();
        let shim = generate("// plugin code", &config);
        assert!(shim.contains("describe-tools"));
        assert!(shim.contains("astrid_tool_call"));
        assert!(shim.contains("astrid_hook_trigger"));
    }

    #[test]
    fn shim_contains_plugin_code() {
        let config = HashMap::new();
        let shim = generate("console.log('hello');", &config);
        assert!(shim.contains("console.log('hello');"));
        assert!(shim.contains("BEGIN PLUGIN CODE"));
        assert!(shim.contains("END PLUGIN CODE"));
    }

    #[test]
    fn shim_bakes_config_keys() {
        let mut config = HashMap::new();
        config.insert("apiKey".into(), serde_json::json!("sk-123"));
        config.insert("timeout".into(), serde_json::json!(30));
        let shim = generate("// code", &config);
        assert!(shim.contains("\"apiKey\""));
        assert!(shim.contains("\"timeout\""));
    }

    #[test]
    fn shim_empty_config() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(shim.contains("var _CONFIG_KEYS = [];"));
    }

    #[test]
    fn shim_has_host_function_wrappers() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(shim.contains("function hostLog("));
        assert!(shim.contains("function hostGetConfig("));
        assert!(shim.contains("function hostReadFile("));
        assert!(shim.contains("function hostWriteFile("));
        assert!(shim.contains("function hostKvGet("));
        assert!(shim.contains("function hostKvSet("));
        assert!(shim.contains("function hostHttpRequest("));
        assert!(shim.contains("function hostFsExists("));
        assert!(shim.contains("function hostFsMkdir("));
        assert!(shim.contains("function hostFsReaddir("));
        assert!(shim.contains("function hostFsStat("));
        assert!(shim.contains("function hostFsUnlink("));
    }

    #[test]
    fn shim_has_node_polyfills() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(shim.contains("_virtualFs"));
        assert!(shim.contains("_virtualPath"));
        assert!(shim.contains("_virtualOs"));
        assert!(shim.contains("function require("));
    }

    #[test]
    fn shim_has_openclaw_context() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(shim.contains("_openclawContext"));
        assert!(shim.contains("registerTool"));
        assert!(shim.contains("_pluginConfig"));
    }

    #[test]
    fn shim_wraps_code_in_iife() {
        let config = HashMap::new();
        let shim = generate("var x = 42;", &config);
        assert!(shim.contains("var _pluginModule = (function()"));
        assert!(shim.contains("var module = { exports: {} };"));
        assert!(shim.contains("return module.exports.default || module.exports;"));
    }

    #[test]
    fn shim_has_deferred_activation() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(
            shim.contains("_ensureActivated()"),
            "should have lazy activation"
        );
        assert!(
            shim.contains("var _activated = false"),
            "should track activation state"
        );
    }

    #[test]
    fn escape_js_string_basics() {
        assert_eq!(escape_js_string("hello"), "hello");
        assert_eq!(escape_js_string("he\"llo"), "he\\\"llo");
        assert_eq!(escape_js_string("a\\b"), "a\\\\b");
        assert_eq!(escape_js_string("a\nb"), "a\\nb");
    }
}
