//! JS shim template generation.
//!
//! Produces a self-contained `JavaScript` file that:
//! 1. Imports Extism host functions (via `Host.getFunctions()`)
//! 2. Wraps the original plugin code in an IIFE with CJS module simulation
//! 3. Provides an `OpenClaw` context mock that maps to Astralis host functions
//! 4. Exports `describe-tools`, `execute-tool`, and `run-hook` for the Extism runtime

use std::collections::HashMap;

/// Generate the complete JS shim wrapping the given plugin code.
///
/// `plugin_code` should be the bundled CJS output from esbuild (or raw JS if `--skip-bundle`).
/// `config` is the set of config key-value pairs to bake into the shim.
#[must_use]
#[allow(clippy::implicit_hasher)]
pub fn generate(plugin_code: &str, config: &HashMap<String, serde_json::Value>) -> String {
    let config_keys = generate_config_keys(config);
    let header = generate_header(&config_keys);
    let exports = generate_exports();
    format!(
        "{header}\n// --- BEGIN PLUGIN CODE ---\n{plugin_code}\n  // --- END PLUGIN CODE ---\n  return module.exports.default || module.exports;\n}})();\n\n{exports}"
    )
}

/// Generate the shim header: host function imports, config loading, context mock, and IIFE open.
fn generate_header(config_keys: &str) -> String {
    format!(
        r#"// Generated by openclaw-bridge — do not edit.
// OpenClaw → Astralis WASM shim.

// ── Host function imports ──────────────────────────────────────────
var _Host = Host;
var _hostFns = _Host.getFunctions();
var _astralis_log = _hostFns.astralis_log;
var _astralis_get_config = _hostFns.astralis_get_config;
var _astralis_read_file = _hostFns.astralis_read_file;
var _astralis_write_file = _hostFns.astralis_write_file;
var _astralis_kv_get = _hostFns.astralis_kv_get;
var _astralis_kv_set = _hostFns.astralis_kv_set;
var _astralis_http_request = _hostFns.astralis_http_request;

// ── Memory helpers ─────────────────────────────────────────────────
function _toMem(s) {{
  return Memory.fromString(String(s));
}}

function _fromMem(offset) {{
  var m = Memory.find(offset);
  if (!m) return "";
  return m.readString();
}}

// ── Host function wrappers ─────────────────────────────────────────
function hostLog(level, msg) {{
  var lm = _toMem(level);
  var mm = _toMem(msg);
  _astralis_log(lm.offset, mm.offset);
}}

function hostGetConfig(key) {{
  var km = _toMem(key);
  var result = _astralis_get_config(km.offset);
  return _fromMem(result);
}}

function hostReadFile(path) {{
  var pm = _toMem(path);
  var result = _astralis_read_file(pm.offset);
  return _fromMem(result);
}}

function hostWriteFile(path, content) {{
  var pm = _toMem(path);
  var cm = _toMem(content);
  _astralis_write_file(pm.offset, cm.offset);
}}

function hostKvGet(key) {{
  var km = _toMem(key);
  var result = _astralis_kv_get(km.offset);
  return _fromMem(result);
}}

function hostKvSet(key, value) {{
  var km = _toMem(key);
  var vm = _toMem(value);
  _astralis_kv_set(km.offset, vm.offset);
}}

function hostHttpRequest(requestJson) {{
  var rm = _toMem(requestJson);
  var result = _astralis_http_request(rm.offset);
  return _fromMem(result);
}}

// ── Config loading (keys baked at generation time) ─────────────────
var _CONFIG_KEYS = [{config_keys}];

var _pluginConfig = {{}};
for (var _ci = 0; _ci < _CONFIG_KEYS.length; _ci++) {{
  var _ck = _CONFIG_KEYS[_ci];
  var _cv = hostGetConfig(_ck);
  if (_cv !== undefined && _cv !== "") {{
    try {{ _pluginConfig[_ck] = JSON.parse(_cv); }}
    catch(_ce) {{ _pluginConfig[_ck] = _cv; }}
  }}
}}

// ── Tool registry ──────────────────────────────────────────────────
var _registeredTools = {{}};

// ── OpenClaw context mock ──────────────────────────────────────────
var _openclawContext = {{
  config: _pluginConfig,
  logger: {{
    info: function(msg) {{ hostLog("info", msg); }},
    warn: function(msg) {{ hostLog("warn", msg); }},
    error: function(msg) {{ hostLog("error", msg); }},
    debug: function(msg) {{ hostLog("debug", msg); }}
  }},
  workspace: ".",
  registerTool: function(name, definition, handler) {{
    _registeredTools[name] = {{
      name: name,
      definition: definition,
      handler: handler
    }};
  }}
}};

// ── Inlined plugin code (IIFE-wrapped CJS) ─────────────────────────
var _pluginModule = (function() {{
  var module = {{ exports: {{}} }};
  var exports = module.exports;"#
    )
}

/// Generate the Extism export functions and activation call.
fn generate_exports() -> String {
    r#"// ── Activation ─────────────────────────────────────────────────────
if (typeof _pluginModule.activate === "function") {
  try {
    _pluginModule.activate(_openclawContext);
  } catch(_ae) {
    hostLog("error", "plugin activation failed: " + String(_ae));
  }
}

// ── Extism exports ─────────────────────────────────────────────────
module.exports["describe-tools"] = function() {
  var tools = [];
  var names = Object.keys(_registeredTools);
  for (var _ti = 0; _ti < names.length; _ti++) {
    var t = _registeredTools[names[_ti]];
    tools.push({
      name: t.name,
      description: t.definition.description || "",
      input_schema: JSON.stringify(t.definition.inputSchema || {})
    });
  }
  _Host.outputString(JSON.stringify(tools));
};

module.exports["execute-tool"] = function() {
  var inputStr = _Host.inputString();
  var input;
  try {
    input = JSON.parse(inputStr);
  } catch(_pe) {
    _Host.outputString(JSON.stringify({
      content: "failed to parse tool input: " + String(_pe),
      is_error: true
    }));
    return;
  }

  var toolName = input.name;
  var tool = _registeredTools[toolName];
  if (!tool) {
    _Host.outputString(JSON.stringify({
      content: "unknown tool: " + toolName,
      is_error: true
    }));
    return;
  }

  var args;
  try {
    args = typeof input.arguments === "string" ? JSON.parse(input.arguments) : (input.arguments || {});
  } catch(_ae2) {
    args = {};
  }

  try {
    var result = tool.handler(toolName, args);
    // Detect unresolved Promise (QuickJS async without event loop)
    if (result && typeof result === "object" && typeof result.then === "function" && typeof result.__value === "undefined") {
      _Host.outputString(JSON.stringify({
        content: "Tool '" + toolName + "' requires async I/O which is not supported in the WASM sandbox. Use the Tier 2 MCP bridge (packages/openclaw-mcp-bridge/) instead.",
        is_error: true
      }));
      return;
    }
    var content = (typeof result === "string") ? result : JSON.stringify(result);
    _Host.outputString(JSON.stringify({
      content: content,
      is_error: false
    }));
  } catch(_ee) {
    _Host.outputString(JSON.stringify({
      content: "tool execution failed: " + String(_ee),
      is_error: true
    }));
  }
};

module.exports["run-hook"] = function() {
  var inputStr = _Host.inputString();
  var ctx;
  try {
    ctx = JSON.parse(inputStr);
  } catch(_pe2) {
    _Host.outputString(JSON.stringify({ action: "continue", data: null }));
    return;
  }

  if (typeof _pluginModule.onEvent === "function") {
    try {
      var eventData = ctx.data ? JSON.parse(ctx.data) : null;
      _pluginModule.onEvent(ctx.event, eventData);
    } catch(_he) {
      hostLog("error", "hook handler failed: " + String(_he));
    }
  }

  _Host.outputString(JSON.stringify({ action: "continue", data: null }));
};
"#
    .to_string()
}

/// Generate the JS array literal for config keys.
fn generate_config_keys(config: &HashMap<String, serde_json::Value>) -> String {
    if config.is_empty() {
        return String::new();
    }
    config
        .keys()
        .map(|k| format!("\"{}\"", escape_js_string(k)))
        .collect::<Vec<_>>()
        .join(", ")
}

/// Escape a string for use in a JS string literal.
fn escape_js_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn shim_contains_exports() {
        let config = HashMap::new();
        let shim = generate("// plugin code", &config);
        assert!(shim.contains("describe-tools"));
        assert!(shim.contains("execute-tool"));
        assert!(shim.contains("run-hook"));
    }

    #[test]
    fn shim_contains_plugin_code() {
        let config = HashMap::new();
        let shim = generate("console.log('hello');", &config);
        assert!(shim.contains("console.log('hello');"));
        assert!(shim.contains("BEGIN PLUGIN CODE"));
        assert!(shim.contains("END PLUGIN CODE"));
    }

    #[test]
    fn shim_bakes_config_keys() {
        let mut config = HashMap::new();
        config.insert("apiKey".into(), serde_json::json!("sk-123"));
        config.insert("timeout".into(), serde_json::json!(30));
        let shim = generate("// code", &config);
        assert!(shim.contains("\"apiKey\""));
        assert!(shim.contains("\"timeout\""));
    }

    #[test]
    fn shim_empty_config() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(shim.contains("var _CONFIG_KEYS = [];"));
    }

    #[test]
    fn shim_has_host_function_wrappers() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(shim.contains("function hostLog("));
        assert!(shim.contains("function hostGetConfig("));
        assert!(shim.contains("function hostReadFile("));
        assert!(shim.contains("function hostWriteFile("));
        assert!(shim.contains("function hostKvGet("));
        assert!(shim.contains("function hostKvSet("));
        assert!(shim.contains("function hostHttpRequest("));
    }

    #[test]
    fn shim_has_openclaw_context() {
        let config = HashMap::new();
        let shim = generate("// code", &config);
        assert!(shim.contains("_openclawContext"));
        assert!(shim.contains("registerTool"));
        assert!(shim.contains("_pluginConfig"));
    }

    #[test]
    fn shim_wraps_code_in_iife() {
        let config = HashMap::new();
        let shim = generate("var x = 42;", &config);
        assert!(shim.contains("var _pluginModule = (function()"));
        assert!(shim.contains("var module = { exports: {} };"));
        assert!(shim.contains("return module.exports.default || module.exports;"));
    }

    #[test]
    fn escape_js_string_basics() {
        assert_eq!(escape_js_string("hello"), "hello");
        assert_eq!(escape_js_string("he\"llo"), "he\\\"llo");
        assert_eq!(escape_js_string("a\\b"), "a\\\\b");
        assert_eq!(escape_js_string("a\nb"), "a\\nb");
    }
}
