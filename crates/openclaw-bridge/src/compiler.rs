//! Wizer-based JS → WASM compilation with embedded `QuickJS` kernel.
//!
//! Replaces the external `extism-js` CLI with an embedded pipeline:
//! 1. Embed the pre-built `QuickJS` WASM kernel via `include_bytes!`
//! 2. Spawn self with hidden `wizer-internal` subcommand
//! 3. Child process runs Wizer on the kernel, reading JS from stdin
//! 4. Parent reads the Wizer'd WASM and stitches named exports
//! 5. Final WASM is written to `output_path`
//!
//! The subprocess is needed because the `QuickJS` kernel reads JS from WASI
//! stdin during `wizer.initialize`. Wizer's `inherit_stdio(true)` passes
//! the process's stdin to the WASM instance. A subprocess lets us control
//! what stdin the WASM sees.

use std::io::Write as _;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};

use crate::error::{BridgeError, BridgeResult};
use crate::export_stitch;

/// The pre-built `QuickJS` WASM kernel from extism/js-pdk.
///
/// This is the `QuickJS` engine compiled to `wasm32-wasip1`. Wizer pre-initializes
/// it with `JavaScript` source code to produce a WASM plugin.
///
/// The kernel is either a real build (placed at `kernel/engine.wasm` by
/// `scripts/build-quickjs-kernel.sh`) or a minimal placeholder (8 bytes)
/// generated by `build.rs` when the kernel isn't available. The placeholder
/// is detected at runtime via size check and produces a helpful error.
const QUICKJS_KERNEL: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/engine.wasm"));

/// Named exports to add to the compiled WASM plugin.
///
/// These must be in alphabetical order to match the sorted index that
/// `QuickJS` uses when looking up `module.exports` keys.
const PLUGIN_EXPORTS: &[&str] = &["describe-tools", "execute-tool", "run-hook"];

/// Compute the blake3 hash of the embedded `QuickJS` kernel.
///
/// Used for compilation cache invalidation — when the kernel changes,
/// all cached compilations must be rebuilt.
#[must_use]
pub fn kernel_hash() -> String {
    blake3::hash(QUICKJS_KERNEL).to_hex().to_string()
}

/// Compile a JS source string to a WASM plugin.
///
/// The `js_source` should be the complete shimmed `JavaScript` (output of
/// `shim::generate`). The compiled WASM is written to `output_path`.
///
/// # Errors
///
/// Returns `BridgeError::CompileFailed` if Wizer fails or the output is invalid.
pub fn compile(js_source: &str, output_path: &Path) -> BridgeResult<()> {
    // Validate the kernel isn't the placeholder stub generated by build.rs.
    // The real QuickJS kernel is ~1.5 MB; the placeholder is 8 bytes.
    // A 10 KB threshold gives ample margin.
    if QUICKJS_KERNEL.len() < 10_000 {
        return Err(BridgeError::CompileFailed(
            "QuickJS kernel is a placeholder stub. Build the real kernel with: \
             ./scripts/build-quickjs-kernel.sh\n\
             See crates/openclaw-bridge/kernel/README.md for manual build instructions."
                .into(),
        ));
    }

    // Step 1: Run Wizer via subprocess to pre-initialize the kernel with JS
    let wizered_wasm = wizer_subprocess(js_source)?;

    // Step 2: Stitch named exports onto the Wizer'd WASM
    let final_wasm = export_stitch::stitch_exports(&wizered_wasm, PLUGIN_EXPORTS)?;

    // Step 3: Validate and write output
    if final_wasm.len() < 8 || &final_wasm[..4] != b"\0asm" {
        return Err(BridgeError::CompileFailed(
            "stitched WASM output is not a valid WASM module".into(),
        ));
    }

    std::fs::write(output_path, &final_wasm)?;
    Ok(())
}

/// Locate the `openclaw-bridge` CLI binary for the Wizer subprocess.
///
/// Search order:
/// 1. `OPENCLAW_BRIDGE_BIN` environment variable
/// 2. Current executable (when running as the CLI)
/// 3. Sibling/ancestor directories (when running as a test binary in `target/debug/deps/`)
fn find_bridge_binary() -> BridgeResult<PathBuf> {
    if let Ok(path) = std::env::var("OPENCLAW_BRIDGE_BIN") {
        let p = PathBuf::from(path);
        if p.exists() {
            return Ok(p);
        }
    }

    let self_exe = std::env::current_exe()
        .map_err(|e| BridgeError::CompileFailed(format!("cannot find own executable: {e}")))?;

    // If we ARE the bridge binary (running as CLI), use ourselves
    if self_exe.file_stem().is_some_and(|s| s == "openclaw-bridge") {
        return Ok(self_exe);
    }

    // When running as a test binary (target/debug/deps/xxx), look in ancestor dirs
    for ancestor in self_exe.ancestors().skip(1).take(3) {
        let candidate = ancestor.join("openclaw-bridge");
        if candidate.is_file() {
            return Ok(candidate);
        }
    }

    Err(BridgeError::CompileFailed(
        "cannot find openclaw-bridge binary for Wizer subprocess. \
         Set OPENCLAW_BRIDGE_BIN or ensure the binary is built."
            .into(),
    ))
}

/// Run Wizer in a subprocess, piping JS source to stdin.
///
/// Finds the `openclaw-bridge` binary and invokes its hidden `wizer-internal`
/// subcommand. The child process runs Wizer on the embedded kernel and writes
/// the pre-initialized WASM to a temp file.
fn wizer_subprocess(js_source: &str) -> BridgeResult<Vec<u8>> {
    let bridge_bin = find_bridge_binary()?;

    // Create a temp file for the Wizer output
    let tmp_dir = tempfile::tempdir()
        .map_err(|e| BridgeError::CompileFailed(format!("failed to create temp dir: {e}")))?;
    let output_path = tmp_dir.path().join("wizered.wasm");

    let mut child = Command::new(&bridge_bin)
        .arg("wizer-internal")
        .arg("--output")
        .arg(&output_path)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .map_err(|e| {
            BridgeError::CompileFailed(format!("failed to spawn wizer subprocess: {e}"))
        })?;

    // Write JS source to child's stdin
    if let Some(mut stdin) = child.stdin.take() {
        stdin.write_all(js_source.as_bytes()).map_err(|e| {
            BridgeError::CompileFailed(format!("failed to write JS to wizer stdin: {e}"))
        })?;
        // Drop stdin to signal EOF
    }

    let output = child
        .wait_with_output()
        .map_err(|e| BridgeError::CompileFailed(format!("wizer subprocess failed: {e}")))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(BridgeError::CompileFailed(format!(
            "wizer subprocess exited with {}: {}",
            output.status,
            stderr.trim()
        )));
    }

    // Read the Wizer'd output
    std::fs::read(&output_path).map_err(|e| {
        BridgeError::CompileFailed(format!(
            "failed to read wizer output at {}: {e}",
            output_path.display()
        ))
    })
}

/// Run Wizer on the embedded kernel with JS from stdin.
///
/// This is called by the hidden `wizer-internal` subcommand.
/// It reads nothing from its own args — the JS comes via stdin
/// (inherited by Wizer's WASI instance).
///
/// # Errors
///
/// Returns an error if Wizer fails to pre-initialize the kernel.
pub fn run_wizer_internal(output_path: &Path) -> BridgeResult<()> {
    let wasm = wizer::Wizer::new()
        .allow_wasi(true)
        .map_err(|e| BridgeError::CompileFailed(format!("wizer WASI setup failed: {e}")))?
        .inherit_stdio(true)
        .wasm_bulk_memory(true)
        .run(QUICKJS_KERNEL)
        .map_err(|e| BridgeError::CompileFailed(format!("wizer failed: {e}")))?;

    std::fs::write(output_path, &wasm)?;
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn kernel_is_embedded() {
        // The kernel bytes should be non-empty (even if just a placeholder)
        assert!(!QUICKJS_KERNEL.is_empty(), "kernel should be embedded");
        assert_eq!(
            &QUICKJS_KERNEL[..4],
            b"\0asm",
            "kernel should start with WASM magic"
        );
    }

    #[test]
    fn kernel_hash_is_stable() {
        let h1 = kernel_hash();
        let h2 = kernel_hash();
        assert_eq!(h1, h2, "kernel_hash should be deterministic");
        assert_eq!(h1.len(), 64, "blake3 hex should be 64 chars");
    }

    #[test]
    fn plugin_exports_are_sorted() {
        // The export names must be alphabetically sorted for QuickJS index mapping
        let mut sorted = PLUGIN_EXPORTS.to_vec();
        sorted.sort();
        assert_eq!(
            PLUGIN_EXPORTS,
            &sorted[..],
            "PLUGIN_EXPORTS must be alphabetically sorted"
        );
    }
}
